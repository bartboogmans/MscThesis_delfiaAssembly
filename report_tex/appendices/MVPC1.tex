% This file was automatically created from the m-file 
% "m2tex.m" written by USL. 
% The fontencoding in this file is UTF-8. 
%  
% You will need to include the following two packages in 
% your LaTeX-Main-File. 
%  
% \usepackage{color} 
% \usepackage{fancyvrb} 
%  
% It is advised to use the following option for Inputenc 
% \usepackage[utf8]{inputenc} 
%  
  
% definition of matlab colors: 
\definecolor{mblue}{rgb}{0,0,1} 
\definecolor{mgreen}{rgb}{0.13333,0.5451,0.13333} 
\definecolor{mred}{rgb}{0.62745,0.12549,0.94118} 
\definecolor{mgrey}{rgb}{0.5,0.5,0.5} 
\definecolor{mdarkgrey}{rgb}{0.25,0.25,0.25} 
  
\DefineShortVerb[fontfamily=courier,fontseries=m]{\$} 
\DefineShortVerb[fontfamily=courier,fontseries=b]{\#} 
  
\noindent                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              $$\color{mblue}$classdef$\color{black}$ MultiVesselPlatformController < Vessel & handle$\\ $$\color{mgreen}$%MultiVesselPlatformController controls an arbitrary configured assembly of$\color{black}$$\\ $$\color{mgreen}$%Delfia-1* vessels$\color{black}$$\\ $    $\color{mgreen}$%   An arbitrary amount of vessels (such as the Delfia.m class) can be$\color{black}$$\\ $    $\color{mgreen}$%   registered as connected in this object. This agent will then take$\color{black}$$\\ $    $\color{mgreen}$%   control of the added vessel, assuming that it is rigidly connected to$\color{black}$$\\ $    $\color{mgreen}$%   all other modules, if present. As a result of changing configuration,$\color{black}$$\\ $    $\color{mgreen}$%   various parameters are approximated for the platform including position$\color{black}$$\\ $    $\color{mgreen}$%   of centre of mass, dynamical model, control gains and parameters to$\color{black}$$\\ $    $\color{mgreen}$%   help distribute control effort over all modules.$\color{black}$$\\ $    $\color{mgreen}$%$\color{black}$$\\ $    $\color{mgreen}$% (c) Bart Boogmans 2020/2021 bartboogmans@hotmail.com,$\color{black}$$\\ $    $\color{mgreen}$% You may use, distribute and modify this code under given that clear$\color{black}$$\\ $    $\color{mgreen}$% credit is given to the author's work.    $\color{black}$$\\ $    $\\ $    properties$\\ $        $\color{mgreen}$% Control structure / hierarchy$\color{black}$$\\ $        bodies          $\color{mgreen}$% array contains handles to vessel objects that are connected or 'owned' by this control object$\color{black}$$\\ $        $\\ $        $\color{mgreen}$%% Control effort generation$\color{black}$$\\ $        PIDs            $\color{mgreen}$% Array if discrete PID controllers $\color{black}$$\\ $        x_r             $\color{mgreen}$% Reference state$\color{black}$$\\ $        e               $\color{mgreen}$% State error$\color{black}$$\\ $        t_last_update   $\color{mgreen}$% Time of last controller update$\color{black}$$\\ $        $\\ $        Kxy_0           $\color{mgreen}$% PID gains for location control reference value$\color{black}$$\\ $        Ka_0            $\color{mgreen}$% PID gains for heading control reference value$\color{black}$$\\ $        $\\ $        $\color{mgreen}$%% Control effort allocation $\color{black}$$\\ $        Cm              $\color{mgreen}$% Actuator Participation coefficient for moment to achieve: Fi, = Cm*R*Mtotal, satsifying sum(mi) = Mtotal and Mi = Ri x Fi$\color{black}$$\\ $        Cf              $\color{mgreen}$% Participation coefficient for force$\color{black}$$\\ $        $\\ $        $\color{mgreen}$%% Configuration dependent parameters$\color{black}$$\\ $        $\\ $        Mres_max        $\color{mgreen}$% Maximum moment that a configuration can attain (linear atm)$\color{black}$$\\ $        Fres_max        $\color{mgreen}$% Maximum force that a configuration can attain (all thrusters on max in a certain direction)$\color{black}$$\\ $        $\\ $        m_av            $\color{mgreen}$% estimated mass, for PID scaling$\color{black}$$\\ $        I_cg            $\color{mgreen}$% estimated moment of inertia around CG$\color{black}$$\\ $        $\\ $        $\color{mgreen}$%% Communication & task scheduling$\color{black}$$\\ $        $\\ $        refSub          $\color{mgreen}$% ROS subscriber to listen to reference updates$\color{black}$$\\ $        refPub          $\color{mgreen}$% ROS publisher to broadcast reference updates$\color{black}$$\\ $        controlPub      $\color{mgreen}$% Publisher to broadcast control related information$\color{black}$$\\ $        node            $\color{mgreen}$% This object's dedicated ROS node$\color{black}$$\\ $        $\\ $        ixx             $\color{mgreen}$% Control update cheduling counter$\color{black}$$\\ $        nr              $\color{mgreen}$% Optional object identifier$\color{black}$$\\ $        $\\ $        $\color{mgreen}$%% Display parameters$\color{black}$$\\ $        plotref      $\color{mgreen}$% Boolean for obj.display to plot reference$\color{black}$$\\ $        plotvessels  $\color{mgreen}$% Boolean for obj.display to plot connected modules$\color{black}$$\\ $        $\\ $    $\color{mblue}$end$\color{black}$$\\ $    $\\ $    methods$\\ $        $\color{mgreen}$% Constructor $\color{black}$$\\ $        $\color{mblue}$function$\color{black}$ obj = MultiVesselPlatformController(x_,y_,yaw_,name_,~)$\\ $            obj = obj@Vessel(x_,y_,yaw_,name_);$\\ $            obj.bodies = Delfia.empty;$\\ $            $\\ $            obj.ixx = 0;$\\ $            obj.w = 0.5;$\\ $            obj.l = 0.5;$\\ $$\\ $            $\color{mgreen}$% Default values of control gains that worked for a single vessel$\color{black}$$\\ $            $\color{mgreen}$% which are scale to time constant and maximum control effort$\color{black}$$\\ $            $\color{mgreen}$% see obj.set_PID_gains$\color{black}$$\\ $            obj.Kxy_0   = [1.0          ,0.0        ,0.0        ];$\\ $            obj.Ka_0    = [0.70/(pi/2)  ,0          ,0.15       ];$\\ $            $\\ $            obj.PIDs = dPID.empty;$\\ $            obj.PIDs(1) = dPID(obj.Kxy_0(1), obj.Kxy_0(2), obj.Kxy_0(3));$\\ $            obj.PIDs(2) = dPID(obj.Kxy_0(1), obj.Kxy_0(2), obj.Kxy_0(3));$\\ $            obj.PIDs(3) = dPID(obj.Ka_0(1), obj.Ka_0(2), obj.Ka_0(3));$\\ $            obj.t_last_update = 0;$\\ $            $\\ $            $\color{mgreen}$% Display$\color{black}$$\\ $            obj.outline = [];$\\ $            obj.plotref = true;$\\ $            obj.plotCG = true;$\\ $        $\color{mblue}$end$\color{black}$$\\ $        $\\ $        $\color{mgreen}$% Destructor$\color{black}$$\\ $        $\color{mblue}$function$\color{black}$ delete(obj)$\\ $            $\\ $            $\color{mblue}$if$\color{black}$ ~isempty(obj.node)$\\ $                disp(join([$\color{mred}$'Deleting '$\color{black}$,obj.name,$\color{mred}$' .node '$\color{black}$,obj.node.Name]))$\\ $                delete(obj.node)$\\ $            $\color{mblue}$end$\color{black}$$\\ $            $\\ $            $\color{mblue}$if$\color{black}$ ~isempty(obj.refSub)$\\ $                disp(join([$\color{mred}$'Deleting '$\color{black}$,obj.name,$\color{mred}$' .refSub '$\color{black}$,obj.refSub.TopicName]))$\\ $                delete(obj.refSub)$\\ $            $\color{mblue}$end$\color{black}$$\\ $            $\\ $            $\color{mblue}$if$\color{black}$ ~isempty(obj.refPub)$\\ $                disp(join([$\color{mred}$'Deleting '$\color{black}$,obj.name,$\color{mred}$' .refPub '$\color{black}$,obj.refPub.TopicName]))$\\ $                delete(obj.refPub)$\\ $            $\color{mblue}$end$\color{black}$$\\ $            $\\ $        $\color{mblue}$end$\color{black}$$\\ $        $\\ $        $\color{mgreen}$%% Adding and removing bodies$\color{black}$$\\ $        $\color{mblue}$function$\color{black}$ attachBody(obj,body)$\\ $            obj.bodies(length(obj.bodies)+1) = body;$\\ $            $\color{mblue}$if$\color{black}$ ~isempty(obj.node)$\\ $                settings = delfiaSettings();$\\ $                body.actuation_publisher =ros.Publisher(obj.node,join([$\color{mred}$'/actuation'$\color{black}$,body.name]),settings.messageTypes.vesselActuation);$\\ $                body.location_subscriber = ros.Subscriber(obj.node,join([$\color{mred}$'/vrpn_client_node/'$\color{black}$,body.name,$\color{mred}$'/pose'$\color{black}$]),settings.messageTypes.vesselPose,{@obj.bodyPoseCallback,body});$\\ $            $\color{mblue}$end$\color{black}$$\\ $            $\\ $            $\color{mgreen}$% Adjust agent behavior to a new configuration$\color{black}$$\\ $            obj.set_configuration_control_parameters;$\\ $            obj.adaptControlAllocationGains;$\\ $            obj.set_PID_gains;$\\ $        $\color{mblue}$end$\color{black}$$\\ $        $\\ $        $\color{mblue}$function$\color{black}$ detatchBody(obj,index)$\\ $            delete(obj.bodies(index).location_subscriber);$\\ $            delete(obj.bodies(index).actuation_publisher);$\\ $            obj.bodies = [obj.bodies(1:index-1),obj.bodies(index+1:length(obj.bodies))];$\\ $            $\\ $            $\color{mgreen}$% Adjust agent behavior to a new configuration$\color{black}$$\\ $            obj.set_configuration_control_parameters;$\\ $            obj.adaptControlAllocationGains;$\\ $            obj.set_PID_gains;$\\ $        $\color{mblue}$end$\color{black}$$\\ $        $\\ $        $\\ $        $\color{mgreen}$%% ROS interaction$\color{black}$$\\ $        $\color{mblue}$function$\color{black}$ initROSNode(obj)$\\ $            $\color{mgreen}$% Initiate this object's ROS node$\color{black}$$\\ $            settings = delfiaSettings();$\\ $            obj.node = ros.Node(obj.name,settings.hostname,$\color{mred}$'NodeHost'$\color{black}$,settings.myIP);$\\ $        $\color{mblue}$end$\color{black}$$\\ $        $\\ $        $\color{mblue}$function$\color{black}$ bodyPoseCallback(obj,~,message,body)$\\ $            $\color{mgreen}$% Respond to a position update of a connected module$\color{black}$$\\ $            $\\ $            body.ros_sub_pose(message);$\\ $            $\color{mblue}$if$\color{black}$ strcmp(body.name,obj.bodies(1).name)$\\ $                $\color{mgreen}$% Only processes location updates of first module for$\color{black}$$\\ $                $\color{mgreen}$% control purposes. Other approaches are possible too.$\color{black}$$\\ $                $\\ $                obj.ixx = obj.ixx +1;$\\ $                $\color{mblue}$if$\color{black}$ obj.ixx == 3$\\ $                    obj.ixx = 0;$\\ $                    $\color{mgreen}$% Reduces frequency of control loop by 2/3.$\color{black}$$\\ $                    $\color{mgreen}$% Only updates controls once per 3 messages, to reduce$\color{black}$$\\ $                    $\color{mgreen}$% frequency from 30 to 10 hz.$\color{black}$$\\ $                    obj.platform_pose_state_estimation(body) $\color{mgreen}$% Set platform state$\color{black}$$\\ $                    $\color{mblue}$if$\color{black}$ ~isempty(obj.x_r)$\\ $                        t = message.Header.Stamp.Sec + message.Header.Stamp.Nsec* 10^-9;$\\ $                        obj.run_controls(t);$\\ $                    $\color{mblue}$end$\color{black}$$\\ $                $\color{mblue}$end$\color{black}$$\\ $            $\color{mblue}$end$\color{black}$$\\ $        $\color{mblue}$end$\color{black}$$\\ $        $\\ $        $\color{mblue}$function$\color{black}$ ros_sub_ref(obj,message)$\\ $            obj.x_r(1:3) =  [message.X;message.Y;message.Theta];$\\ $        $\color{mblue}$end$\color{black}$$\\ $        $\\ $        $\color{mblue}$function$\color{black}$ ros_pub_ref(obj)$\\ $            msg = rosmessage(obj.refPub);$\\ $            msg.X = obj.x_r(1);$\\ $            msg.Y = obj.x_r(2);$\\ $            msg.Theta = obj.x_r(3);$\\ $            send(obj.refPub,msg);$\\ $        $\color{mblue}$end$\color{black}$$\\ $        $\\ $        $\color{mblue}$function$\color{black}$ ros_pub_actuation(obj)$\\ $            $\color{mblue}$for$\color{black}$ vessel = obj.bodies$\\ $                vessel.ros_pub_actuation;$\\ $            $\color{mblue}$end$\color{black}$$\\ $        $\color{mblue}$end$\color{black}$$\\ $        $\\ $        $\color{mblue}$function$\color{black}$ ros_pub_controlparams(obj)$\\ $            $\color{mblue}$if$\color{black}$ ~isempty(obj.node)$\\ $                $\color{mblue}$if$\color{black}$ ~isempty(obj.node)$\\ $                    msg = rosmessage(obj.controlPub);$\\ $                    msg.Data = [obj.thrSpd(1),obj.thrSpd(2),obj.thrAngle(1),obj.thrAngle(2)];$\\ $                    send(obj.actuation_publisher,msg);$\\ $                $\color{mblue}$end$\color{black}$$\\ $            $\color{mblue}$end$\color{black}$$\\ $        $\color{mblue}$end$\color{black}$$\\ $        $\\ $        $\color{mgreen}$%% State estimation$\color{black}$$\\ $        $\color{mblue}$function$\color{black}$ platform_pose_state_estimation(obj,body)$\\ $            p_pnn = body.x(1:2) + R2d(body.x(3))*R2d(-body.platf_eta(3))*-body.platf_eta(1:2);$\\ $            psi_pn = body.x(3) -body.platf_eta(3);$\\ $            obj.x(1:3) = [p_pnn;psi_pn];$\\ $        $\color{mblue}$end$\color{black}$$\\ $        $\\ $        $\color{mgreen}$%% Control planning$\color{black}$$\\ $        $\\ $        $\color{mblue}$function$\color{black}$ run_controls(obj,systime)$\\ $            dt = systime-obj.t_last_update;$\\ $            $\\ $            $\color{mgreen}$% calculate errors$\color{black}$$\\ $            obj.e = obj.calcError(obj.x_r);$\\ $            $\\ $            $\color{mgreen}$% Run controllers to update desired control effort$\color{black}$$\\ $            Fx = obj.PIDs(1).run(obj.e(1),dt);$\\ $            Fy = obj.PIDs(2).run(obj.e(2),dt);$\\ $            Mc = obj.PIDs(3).run(obj.e(3),dt);$\\ $            $\\ $            $\color{mgreen}$% Allocate control effort$\color{black}$$\\ $            F_ = R2d(-obj.x(3))*[Fx;Fy]; $\color{mgreen}$% convert global input to force vector in local frame$\color{black}$$\\ $            obj.actuate(F_,Mc);$\\ $            $\\ $            $\color{mgreen}$% Broadcast module commands over ROS$\color{black}$$\\ $            $\\ $            $\color{mblue}$if$\color{black}$ ~isempty(obj.node)$\\ $                $\color{mblue}$if$\color{black}$ ~isempty(obj.controlPub)$\\ $                    msg = rosmessage(obj.controlPub);$\\ $                    msg.Data = [obj.e(1),obj.e(2),obj.e(3),F_(1),F_(2),Mc];$\\ $                    send(obj.controlPub,msg);$\\ $                $\color{mblue}$end$\color{black}$$\\ $            $\color{mblue}$end$\color{black}$$\\ $            $\\ $            $\color{mblue}$for$\color{black}$ vessel = obj.bodies$\\ $                vessel.calcThrSpd();$\\ $                vessel.ros_pub_actuation;$\\ $            $\color{mblue}$end$\color{black}$$\\ $            $\\ $            obj.t_last_update =  systime;$\\ $        $\color{mblue}$end$\color{black}$$\\ $        $\\ $        $\\ $        $\color{mgreen}$% actuate allocates control effort$\color{black}$$\\ $        $\color{mgreen}$% Connected modules have their participating actuation set. $\color{black}$$\\ $        $\color{mblue}$function$\color{black}$ actuate(obj,F,M)            $\\ $            $\color{mblue}$for$\color{black}$ vessel = obj.bodies $\color{mgreen}$% For each vessel on rigid body$\color{black}$$\\ $                $\color{mblue}$for$\color{black}$ i = 1:length(vessel.r_thr) $\color{mgreen}$% For each thruster on vessel$\color{black}$$\\ $                    $\\ $                    r_pf = R2d(vessel.platf_eta(3))*vessel.r_thr(i,:)' + vessel.platf_eta(1:2) - obj.r_CoM; $\color{mgreen}$% location with respect to Centre of mass in platform frame$\color{black}$$\\ $$\\ $                    Fm = obj.Cm * M*([-r_pf(2);r_pf(1)]);    $\color{mgreen}$% Desired force to do a share in attaining resultant moment. Note how r_pf is flipped.$\color{black}$$\\ $                    Ff = obj.Cf * F;                        $\color{mgreen}$% Desired force to do a share in attaining resultant force$\color{black}$$\\ $                    $\\ $                    F_thr_pf = Fm+Ff;                                 $\color{mgreen}$% Thruster force in platform frame$\color{black}$$\\ $                    F_thr_vf = R2d(-vessel.platf_eta(3))*F_thr_pf;    $\color{mgreen}$% Thruster force converted to vessel frame$\color{black}$$\\ $                    $\\ $                    $\color{mgreen}$%Set the vessel's thruster$\color{black}$$\\ $                    vessel.thrForce(i) = sqrt(F_thr_vf(1)^2 + F_thr_vf(2)^2);$\\ $                    $\color{mblue}$if$\color{black}$ vessel.thrForce(i) > 0 $\color{mgreen}$% Only adjust thruster angle if it is active$\color{black}$$\\ $                        vessel.thrAngle(i) = angle(F_thr_vf(1)+1i*F_thr_vf(2));$\\ $                    $\color{mblue}$end$\color{black}$$\\ $                $\color{mblue}$end$\color{black}$$\\ $                $\\ $                $\color{mgreen}$% Set propeller speeds$\color{black}$$\\ $                vessel.calcThrSpd;$\\ $                vessel.bound_motor_speeds();$\\ $            $\color{mblue}$end$\color{black}$$\\ $        $\color{mblue}$end$\color{black}$$\\ $        $\\ $        $\color{mgreen}$% Calculate resultant forces of actuator input, given the centre of$\color{black}$$\\ $        $\color{mgreen}$% mass has already been identified.$\color{black}$$\\ $        $\color{mblue}$function$\color{black}$ tau = resultant_control_effort(obj)$\\ $            Mres = 0;$\\ $            Fres = [0;0];$\\ $            $\color{mblue}$for$\color{black}$ vessel = obj.bodies$\\ $                $\color{mblue}$for$\color{black}$ i = 1:length(vessel.r_thr)$\\ $                    r_c_pf = R2d(vessel.platf_eta(3))*(vessel.r_thr(i,:)') + vessel.platf_eta(1:2) - obj.r_CoM;$\\ $                    $\\ $                    Fthr_vessel = R2d(vessel.thrAngle(i)) * [vessel.thrForce(i);0];$\\ $                    Fthr_pf = R2d(vessel.platf_eta(3))*Fthr_vessel;$\\ $                    $\\ $                    Mi = cross([r_c_pf',0],[Fthr_pf',0]);$\\ $                    Mres = Mres + Mi(3);$\\ $                    Fres = Fres+ Fthr_pf;$\\ $                $\color{mblue}$end$\color{black}$$\\ $            $\color{mblue}$end$\color{black}$$\\ $            tau = [Fres;Mres];$\\ $        $\color{mblue}$end$\color{black}$$\\ $        $\\ $        $\\ $        $\color{mgreen}$%% Control strategy adaptation to configuration$\color{black}$$\\ $        $\color{mblue}$function$\color{black}$ adaptControlAllocationGains(obj)$\\ $            $\color{mgreen}$% Control allocation gain adaptation$\color{black}$$\\ $            CmtotInv = 0;$\\ $            numActuators = 0;$\\ $            $\color{mblue}$for$\color{black}$ n = 1:length(obj.bodies) $\color{mgreen}$% For each vessel on rigid body$\color{black}$$\\ $                vessel = obj.bodies(n);$\\ $                $\color{mblue}$for$\color{black}$ i = 1:length(vessel.r_thr) $\color{mgreen}$% For each thruster on vessel$\color{black}$$\\ $                    r_c = R2d(vessel.platf_eta(3))*vessel.r_thr(i,:)' + vessel.platf_eta(1:2) - obj.r_CoM;$\\ $                    CmtotInv = CmtotInv+ r_c(1)^2 + r_c(2)^2;$\\ $                    numActuators = numActuators +1;$\\ $                $\color{mblue}$end$\color{black}$$\\ $            $\color{mblue}$end$\color{black}$$\\ $            obj.Cm = 1/CmtotInv;$\\ $            obj.Cf = 1/numActuators;$\\ $        $\color{mblue}$end$\color{black}$$\\ $        $\\ $        $\color{mblue}$function$\color{black}$ M = findMaxMoment(obj)$\\ $            $\color{mgreen}$% While aplying a linear moment/r, find Maximum M$\color{black}$$\\ $            $\color{mgreen}$% Find furthest thruster distance to CoM$\color{black}$$\\ $            r_max = 0;$\\ $            $\color{mblue}$for$\color{black}$ n = 1:length(obj.bodies) $\color{mgreen}$% For each vessel on rigid body$\color{black}$$\\ $                vessel = obj.bodies(n);$\\ $                $\color{mblue}$for$\color{black}$ i = 1:length(vessel.r_thr) $\color{mgreen}$% For each thruster on vessel$\color{black}$$\\ $                    r_pf = R2d(vessel.platf_eta(3))*vessel.r_thr(i,:)' + vessel.platf_eta(1:2) - obj.r_CoM; $\color{mgreen}$% location with respect to Centre of mass in platform frame$\color{black}$$\\ $                    r_abs = sqrt(r_pf(1)^2+r_pf(2)^2);$\\ $                    $\color{mblue}$if$\color{black}$ r_abs>r_max$\\ $                        r_max = r_abs;$\\ $                    $\color{mblue}$end$\color{black}$$\\ $                $\color{mblue}$end$\color{black}$$\\ $            $\color{mblue}$end$\color{black}$$\\ $            $\\ $            $\color{mgreen}$% Set all actuators to full moment participation$\color{black}$$\\ $            $\color{mblue}$for$\color{black}$ n = 1:length(obj.bodies) $\color{mgreen}$% For each vessel on rigid body$\color{black}$$\\ $                vessel = obj.bodies(n);$\\ $                $\color{mblue}$for$\color{black}$ i = 1:length(vessel.r_thr) $\color{mgreen}$% For each thruster on vessel$\color{black}$$\\ $                    r_pf = R2d(vessel.platf_eta(3))*vessel.r_thr(i,:)' + vessel.platf_eta(1:2) - obj.r_CoM;$\\ $                    $\color{mgreen}$%r_pf_abs = sqrt(r_pf(1)^2+r_pf(2)^2);$\color{black}$$\\ $                    Fi = [-r_pf(2);r_pf(1)]/r_max* vessel.thrFmax;$\\ $                    F_vf = R2d(-vessel.platf_eta(3))*Fi;$\\ $                    $\color{mgreen}$%vessel.thrusterforce_to_actuation(i,F_vf)$\color{black}$$\\ $                    $\\ $                    $\color{mgreen}$%Set the vessel's thruster$\color{black}$$\\ $                    vessel.thrForce(i) = sqrt(F_vf(1)^2 + F_vf(2)^2);$\\ $                    $\color{mblue}$if$\color{black}$ vessel.thrForce(i) > 0 $\color{mgreen}$% Only adjust thruster angle if it is active$\color{black}$$\\ $                        vessel.thrAngle(i) = angle(F_vf(1)+1i*F_vf(2));$\\ $                    $\color{mblue}$end$\color{black}$$\\ $                $\color{mblue}$end$\color{black}$$\\ $            $\color{mblue}$end$\color{black}$$\\ $            $\\ $            $\color{mgreen}$% Calculate the Moment of current actuation$\color{black}$$\\ $            tau = obj.resultant_control_effort;$\\ $            M = tau(3);$\\ $        $\color{mblue}$end$\color{black}$$\\ $        $\\ $        $\color{mblue}$function$\color{black}$ F = findMaxForce(obj)$\\ $            $\color{mgreen}$% find maximum resultant force due to propellors in x,y$\color{black}$$\\ $            Fsum = 0;$\\ $            $\color{mblue}$for$\color{black}$ n = 1:length(obj.bodies) $\color{mgreen}$% For each vessel on rigid body$\color{black}$$\\ $                vessel = obj.bodies(n);$\\ $                $\color{mblue}$for$\color{black}$ i = 1:length(vessel.r_thr) $\color{mgreen}$% For each thruster on vessel$\color{black}$$\\ $                    Fsum = Fsum+vessel.thrFmax;$\\ $                $\color{mblue}$end$\color{black}$$\\ $            $\color{mblue}$end$\color{black}$$\\ $            F = Fsum;$\\ $        $\color{mblue}$end$\color{black}$$\\ $        $\\ $        $\\ $        $\color{mblue}$function$\color{black}$ set_PID_gains(obj)$\\ $            $\color{mgreen}$% Adapt control gains to current configuration and model$\color{black}$$\\ $            $\color{mgreen}$% parameters$\color{black}$$\\ $            $\\ $            $\color{mgreen}$% Make sure used model parameters are computed$\color{black}$$\\ $            obj.set_configuration_control_parameters;$\\ $            $\\ $            $\color{mgreen}$% Estimated time constant for linear motion$\color{black}$$\\ $            $\color{mgreen}$% The time constant is a_current/a_singleVessel$\color{black}$$\\ $            Fmax_single = 0.4320000;                $\color{mgreen}$% N$\color{black}$$\\ $            m_av_single = 4.1275;                   $\color{mgreen}$% Kg ( this value was earlier set to 0.04710000; for some reason, which makes no sense to me. replaced it with correct value [bb]$\color{black}$$\\ $            Fmax_current = obj.findMaxForce;        $\color{mgreen}$% N$\color{black}$$\\ $            m_av_current = obj.m_av ;               $\color{mgreen}$% Kg$\color{black}$$\\ $            C_t_xy = (Fmax_current/Fmax_single)*(m_av_single/m_av_current);$\\ $            $\\ $            $\color{mgreen}$% Estimated time constant for angular motion$\color{black}$$\\ $            $\color{mgreen}$% Time constant is similar, based on maximum angular$\color{black}$$\\ $            $\color{mgreen}$% accelleration ratio$\color{black}$$\\ $            Mmax_single = 0.066960000000;           $\color{mgreen}$% Nm$\color{black}$$\\ $            I_single = 0.1410;                      $\color{mgreen}$% Kg * m^2$\color{black}$$\\ $            Mmax_current = obj.findMaxMoment;       $\color{mgreen}$% Nm$\color{black}$$\\ $            I_cg_current = obj.I_cg;                $\color{mgreen}$% Kg * m^2$\color{black}$$\\ $            C_t_yaw = (Mmax_current/Mmax_single)*(I_single/I_cg_current);$\\ $            $\\ $            $\color{mgreen}$% Pid gains are based on time constant with respect to single$\color{black}$$\\ $            $\color{mgreen}$% vessel configuration tuning$\color{black}$$\\ $            obj.PIDs(1).Kp = obj.Kxy_0(1)*Fmax_current;             $\color{mgreen}$% N/m$\color{black}$$\\ $            obj.PIDs(1).Ki = obj.Kxy_0(2)*Fmax_current*C_t_xy;      $\color{mgreen}$% N*s/m$\color{black}$$\\ $            obj.PIDs(1).Kd = obj.Kxy_0(3)*Fmax_current/C_t_xy;      $\color{mgreen}$% N/s/m$\color{black}$$\\ $            $\\ $            obj.PIDs(2).Kp = obj.Kxy_0(1)*Fmax_current;             $\color{mgreen}$% N/m$\color{black}$$\\ $            obj.PIDs(2).Ki = obj.Kxy_0(2)*Fmax_current*C_t_xy;      $\color{mgreen}$% N*s/m$\color{black}$$\\ $            obj.PIDs(2).Kd = obj.Kxy_0(3)*Fmax_current/C_t_xy;      $\color{mgreen}$% N/s/m$\color{black}$$\\ $            $\\ $            obj.PIDs(3).Kp = obj.Ka_0(1)*Mmax_current;              $\color{mgreen}$% N*m /rad$\color{black}$$\\ $            obj.PIDs(3).Ki = obj.Ka_0(2)*Mmax_current*C_t_yaw;      $\color{mgreen}$% N*m*s/rad$\color{black}$$\\ $            obj.PIDs(3).Kd = obj.Ka_0(3)*Mmax_current/C_t_yaw;      $\color{mgreen}$% N*m/s/rad$\color{black}$$\\ $        $\color{mblue}$end$\color{black}$$\\ $        $\\ $        $\color{mblue}$function$\color{black}$ M = set_Inertial_Matrix(obj)$\\ $            M = zeros(3);$\\ $            $\color{mblue}$for$\color{black}$ v = 1:length(obj.bodies)$\\ $                H = H3_transf(obj.bodies(v).platf_eta(1:2));$\\ $                J =  R2d3(-obj.bodies(v).platf_eta(3));$\\ $                M = M + H'*J'*obj.bodies(v).M*J*H;$\\ $            $\color{mblue}$end$\color{black}$$\\ $            obj.M = M;$\\ $        $\color{mblue}$end$\color{black}$$\\ $        $\\ $        $\color{mblue}$function$\color{black}$ cg = set_CG(obj)$\\ $            $\color{mblue}$if$\color{black}$ ~isempty(obj.M)$\\ $                $\color{mblue}$if$\color{black}$ size(obj.M) == [3,3]$\\ $                    m11 = obj.M(1:2,1:2);$\\ $                    m12 = obj.M(1:2,3);$\\ $                    r_ = inv(m11)*m12; $\color{mgreen}$% in 6d this would be S(r) = m11^(-1) * m12$\color{black}$$\\ $                    cg = [r_(2);-r_(1)];$\\ $                    obj.r_CoM = cg;$\\ $                $\color{mblue}$end$\color{black}$$\\ $            $\color{mblue}$end$\color{black}$$\\ $        $\color{mblue}$end$\color{black}$$\\ $        $\\ $        $\color{mblue}$function$\color{black}$ set_configuration_control_parameters(obj)$\\ $            obj.set_Inertial_Matrix;$\\ $            obj.set_CG;$\\ $            $\\ $            M_cg = H3_transf(-obj.r_CoM)'*obj.M*H3_transf(-obj.r_CoM);$\\ $            obj.m_av = sum(eig(M_cg(1:2,1:2)))/2;$\\ $            obj.I_cg = M_cg(3,3);$\\ $        $\color{mblue}$end$\color{black}$$\\ $        $\\ $        $\color{mblue}$function$\color{black}$ [Dxy,Dyaw]  = estimate_dampening_linear(obj)$\\ $            $\color{mgreen}$% Using a linear dampening model from modules to estimate$\color{black}$$\\ $            $\color{mgreen}$% dampening on platform$\color{black}$$\\ $            [~,~,D,~] = Delfia_Model([0 0 0 0 0 0]);$\\ $            Dp = zeros(3);$\\ $            $\color{mblue}$for$\color{black}$ v = 1:length(obj.bodies)$\\ $                H = H3_transf(obj.bodies(v).platf_eta(1:2));$\\ $                J =  R2d3(-obj.bodies(v).platf_eta(3));$\\ $                Dp = Dp + H'*J'*D*J*H;$\\ $            $\color{mblue}$end$\color{black}$$\\ $            Dp_cg = H3_transf(-obj.r_CoM)'*Dp*H3_transf(-obj.r_CoM);$\\ $            $\\ $            $\color{mgreen}$% Coupling of dampening wrt the centre of gravity can$\color{black}$$\\ $            $\color{mgreen}$% have off diagonal terms, including coupling between rotation$\color{black}$$\\ $            $\color{mgreen}$% and translation. The latter is neglected for estimating order$\color{black}$$\\ $            $\color{mgreen}$% of magnitude of dampening$\color{black}$$\\ $            Dxy = sum(eig(Dp_cg(1:2,1:2)))/2;$\\ $            Dyaw = Dp_cg(3,3);$\\ $        $\color{mblue}$end$\color{black}$$\\ $                $\\ $        $\color{mgreen}$%% Display$\color{black}$$\\ $        $\\ $        $\color{mblue}$function$\color{black}$ plotPlatform(obj,UI_axis)$\\ $            $\color{mgreen}$% Display a representation of the assembly in axes$\color{black}$$\\ $            $\color{mblue}$if$\color{black}$ obj.plotvessels == true$\\ $                $\color{mblue}$if$\color{black}$ ~isempty(obj.bodies)$\\ $                    $\color{mblue}$for$\color{black}$ body = obj.bodies$\\ $                        body.plotVessel(UI_axis);$\\ $                    $\color{mblue}$end$\color{black}$$\\ $                $\color{mblue}$end$\color{black}$$\\ $            $\color{mblue}$end$\color{black}$$\\ $            $\color{mblue}$if$\color{black}$ obj.plotref==true$\\ $                obj.plotReferenceAxis(UI_axis)$\\ $            $\color{mblue}$end$\color{black}$$\\ $        $\color{mblue}$end$\color{black}$$\\ $        $\\ $        $\color{mblue}$function$\color{black}$ plotReferenceAxis(obj,UI_axis)$\\ $            $\color{mgreen}$% Display reference point in axes$\color{black}$$\\ $            $\color{mblue}$if$\color{black}$ ~isempty(obj.x_r)$\\ $                L_axis = max(obj.w,obj.l)/4; $\color{mgreen}$% to scale axis to vessel$\color{black}$$\\ $                R=R2d(obj.x_r(3));$\\ $                rx = R*[0,L_axis;0,0]+ obj.x_r(1:2)';$\\ $                ry = R*[0,0;0,L_axis]+ obj.x_r(1:2)';$\\ $                plot(UI_axis,rx(1,:),rx(2,:),$\color{mred}$'color'$\color{black}$,[$\color{mred}$0.7 0 0]);$\color{black}$$\\ $                plot(UI_axis,ry(1,:),ry(2,:),$\color{mred}$'color'$\color{black}$,[0 $\color{mred}$0.7 0]);$\color{black}$$\\ $            $\color{mblue}$end$\color{black}$$\\ $        $\color{mblue}$end$\color{black}$$\\ $        $\\ $        $\color{mblue}$function$\color{black}$ plotPlatform_blueprint(obj,UI_axis)$\\ $            $\color{mgreen}$% Display opaque blueprint of assembly at reference pose$\color{black}$$\\ $            $\color{mblue}$if$\color{black}$ ~isempty(obj.bodies)$\\ $                $\color{mblue}$for$\color{black}$ body = obj.bodies$\\ $                    eta = R2d3(obj.x(3))*body.platf_eta + obj.x(1:3);$\\ $                    tempDelfia = Delfia(eta(1),eta(2),eta(3));$\\ $                    tempDelfia.plotThr = false;$\\ $                    tempDelfia.plotF = false;$\\ $                    tempDelfia.plotname = false;$\\ $                    tempDelfia.plotaxis = true;$\\ $                    tempDelfia.color = 1-(1-obj.color)*0.8; $\color{mgreen}$% slightly opaque$\color{black}$$\\ $                    tempDelfia.plotVessel(UI_axis)$\\ $                $\color{mblue}$end$\color{black}$$\\ $            $\color{mblue}$end$\color{black}$$\\ $            $\color{mblue}$if$\color{black}$ obj.plotCG==true$\\ $                $\color{mblue}$if$\color{black}$ ~isempty(obj.r_CoM)$\\ $                    r = R2d(obj.x(3))*obj.r_CoM + obj.x(1:2);$\\ $                    plot(UI_axis,r(1),r(2),$\color{mred}$'*k'$\color{black}$);$\\ $                $\color{mblue}$end$\color{black}$$\\ $            $\color{mblue}$end$\color{black}$$\\ $            $\color{mgreen}$% Plot reference axis$\color{black}$$\\ $            $\color{mblue}$if$\color{black}$ obj.plotref==true$\\ $                obj.plotReferenceAxis(UI_axis)$\\ $            $\color{mblue}$end$\color{black}$$\\ $        $\color{mblue}$end$\color{black}$$\\ $    $\color{mblue}$end$\color{black}$$\\ $$\color{mblue}$end$\color{black}$$\\ 
  
\UndefineShortVerb{\$} 
\UndefineShortVerb{\#}